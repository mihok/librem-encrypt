#!/usr/bin/ash

run_hook() {
    modprobe -a -q dm-crypt >/dev/null 2>&1
    [ "${quiet}" = "y" ] && CSQUIET=">/dev/null"

    # Get keyfile
    ckeyfile="/crypto_keyfile.bin"
    if [ -n "$cryptkey" ]; then
        IFS=: read ckdev ckarg1 ckarg2 <<EOF
$cryptkey
EOF

        if [ "$ckdev" = "rootfs" ]; then
            ckeyfile=$ckarg1
        elif resolved=$(resolve_device "${ckdev}" ${rootdelay}); then
            case ${ckarg1} in
                *[!0-9]*)
                    # Use a file on the device
                    # ckarg1 is not numeric: ckarg1=filesystem, ckarg2=path
                    mkdir /c
                    mount -r -t "$ckarg1" "$resolved" /c

                    msg "Checking if crypto key is gpg based '${ckarg2%.gpg}' '${ckarg2}'"

                    if [ -r "${ckarg2}" ] && [ "${ckarg2%.gpg}" != "${ckarg2}" ]; then
                        # Smartcard reader daemon
                        msg "Starting PC/SC smart card daemon"
                        pcscd --auto-exit &> /dev/null

                        msg "Checking for OpenPGP smart card"
                        gpg --homedir "/etc/initcpio/gpg" --import /etc/initcpio/gpg/pubkey.gpg

                        if [ 0 -ne $? ] ; then
                            err "Failed to import public key, aborting..."
                            return 1
                        fi

                        # Test communication with card - this is also needed for decryption
                        # to work at all
                        gpg --homedir "/etc/initcpio/gpg" --card-status >/dev/null 2>&1

                        msg "Key decrypted!"

                        cat "/c/$ckarg2" | gpg -d > $ckeyfile >/dev/null 2>&1

                        # Cleanup
                        killall gpg-agent scdaemon pcscd &> /dev/null
                    else
                        dd if="/c/$ckarg2" of="$ckeyfile" >/dev/null 2>&1
                    fi

                    umount /c

                    ;;
                *)
                    # Read raw data from the block device
                    # ckarg1 is numeric: ckarg1=offset, ckarg2=length
                    dd if="$resolved" of="$ckeyfile" bs=1 skip="$ckarg1" count="$ckarg2" >/dev/null 2>&1
                    ;;
            esac
        fi

        if [ ! -f ${ckeyfile} ]; then
           err "Keyfile could not be opened, aborting... "
           return 1
        fi
    fi

    # Device information
    if [ -n "${cryptdevice}" ]; then
        IFS=: read cryptdev cryptname cryptoptions <<EOF
$cryptdevice
EOF
    else
        err "No device to decrypt, did you specify a cryptdevice=device:dmname?"
        return 1
    fi

    # This may happen if third party hooks do the crypt setup
    if [ -b "/dev/mapper/${cryptname}" ]; then
        echo "Device ${cryptname} already exists, not doing any crypt setup."
        return 0
    fi

    # Options
    for cryptopt in ${cryptoptions//,/ }; do
        case ${cryptopt} in
            # allow-discards)
            #     cryptargs="${cryptargs} --allow-discards"
            #     ;;
            *)
                echo "Encryption option '${cryptopt}' not known, ignoring." >&2
                ;;
        esac
    done
    msg "Encryption options '${cryptargs}'"


    if resolved=$(resolve_device "${cryptdev}" {rootdelay}); then
        if [ -n "${crypto}" ]; then
            if echo "$crypto" | awk -F: '{ exit(NF == 5) }'; then
                err "Verify parameter format: crypto=hash:cipher:keysize:offset:skip"
                err "dm-crypt plain decryption not attempted..."
                return 1
            fi
            exe="cryptsetup open --type plain $resolved $cryptname $cryptargs"
            IFS=: read c_hash c_cipher c_keysize c_offset c_skip <<EOF
$crypto
EOF
            [ -n "$c_hash" ]    && exe="$exe --hash '$c_hash'"
            [ -n "$c_cipher" ]  && exe="$exe --cipher '$c_cipher'"
            [ -n "$c_keysize" ] && exe="$exe --key-size '$c_keysize'"
            [ -n "$c_offset" ]  && exe="$exe --offset '$c_offset'"
            [ -n "$c_skip" ]    && exe="$exe --skip '$c_skip'"
            if [ -f "$ckeyfile" ]; then
                exe="$exe --key-file $ckeyfile"
            else
                echo ""
                echo "A password is required to access the ${cryptname} volume:"
            fi
            eval "$exe $CSQUIET"

            if [ $? -ne 0 ]; then
                err "Non-LUKS device decryption failed. verify format: "
                err "      crypto=hash:cipher:keysize:offset:skip"
                return 1
            fi
            if [ -e "/dev/mapper/${cryptname}" ]; then
                if [ ${DEPRECATED_CRYPT} -eq 1 ]; then
                    export root="/dev/mapper/root"
                fi
            else
                err "Password succeeded, but ${cryptname} creation failed, aborting..."
                return 1
            fi

        else
            err "Failed to open encryption mapping: The device ${cryptdev} is not a dm-encrypt plain volume and the crypto= paramater was not specified."
        fi

    fi

    rm -f ${ckeyfile}
}

